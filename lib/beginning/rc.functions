#!/bin/bash
#
# Beginning - an rc program that doesn't try to be too clever
#
# Copyright (c) 2015 Kylie McClain <somasis@exherbo.org>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

umask 022

export PATH="/bin:/sbin"

# os-release contains things such as distro name, distro's 'color'...
[[ -r /lib/os-release ]] && . /lib/os-release
[[ -r /lib/beginning/rc.conf ]] && . /lib/beginning/rc.conf
[[ -r /etc/os-release ]] && . /etc/os-release
[[ -r /etc/rc.conf ]] && . /etc/rc.conf

if [[ ! -r /lib/beginning/rc.conf && ! -f /etc/rc.conf ]];then
    printf 'Could not read/find %s/rc.conf or %s/rc.conf, going into emergency shell...\n' /lib/beginning /etc
    emergency_shell
fi

# If os-release gives us a color, use it; if not, use the reset color code
ANSI_COLOR="\e[${ANSI_COLOR:-0}m"
[[ -z "$PRETTY_NAME" ]] && PRETTY_NAME=${NAME:-Linux}


tabprefix() {
    if [[ "$PPID" -eq 1 ]];then
        while read line;do
            printf '\t%s\n' "$line"
        done
    else
        cat /dev/stdin
    fi
}

emergency_shell() {
    while true;do
        sulogin && exec "$@"
    done
}

reverse() {
    if [[ $# -ne 0 ]];then
        local rev="$1"
        shift
        reverse "$@"
        printf '%s\n' "$rev"
    fi
}

unset_phases() {
    for func in ${daemon:-$1}_{start,reload,restart,stop,depends};do
        type -t "${func}" >/dev/null 2>&1 && unset -f "${func}"
    done
}

beginning_daemon_start() {
    export BEGINNING_PHASE=start
    local daemon
    for daemon in ${@};do
        if [[ -f /run/beginning/started.${daemon} ]];then
            continue
        elif [[ -f "/etc/rc.d/${daemon}" ]];then
            daemon_file="/etc/rc.d/${daemon}"
        elif [[ -f "/lib/beginning/rc.d/${daemon}" ]];then
            daemon_file="/lib/beginning/rc.d/${daemon}"
        else
            printf "\tCannot find rc.d script for %s. Skipping.\n" "${daemon}" >&2
        fi
        if [[ "${daemon_file}" ]];then
            . "${daemon_file}" || printf "\t%s's rc.d script is invalid. Skipping.\n" "${daemon}" >&2
            if [[ -z "$BEGINNING_NO_RESOLVE_DEPENDS" ]];then
                type -t ${daemon}_depends >/dev/null 2>&1 && beginning_daemon_start $(${daemon}_depends)
            fi
            if type -t ${daemon}_start >/dev/null 2>&1;then
                printf "Starting \`%s\`..." "${daemon}" | tabprefix
                ${daemon}_start
                if [[ $? -eq 0 ]];then
                    rm -f /run/beginning/failed.${daemon}
                    date +%s > /run/beginning/started.${daemon}
                    printf " done.\n"
                else
                    rm -f /run/beginning/started.${daemon}
                    date +%s > /run/beginning/failed.${daemon}
                    printf " failed.\n"
                fi
            fi
        fi
    done
}

beginning_daemon_stop() {
    export BEGINNING_PHASE=stop
    local daemon
    for daemon in ${@};do
        if [[ ! -f /run/beginning/started.${daemon} ]];then
            continue
        elif [[ -f "/etc/rc.d/${daemon}" ]];then
            daemon_file="/etc/rc.d/${daemon}"
        elif [[ -f "/lib/beginning/rc.d/${daemon}" ]];then
            daemon_file="/lib/beginning/rc.d/${daemon}"
        else
            printf "\tCannot find rc.d script for %s. Skipping.\n" "${daemon}" >&2
        fi
        if [[ "${daemon_file}" ]];then
            . "${daemon_file}" || printf "\t%s's rc.d script is invalid. Skipping.\n" "${daemon}" >&2
            if [[ -z "$BEGINNING_NO_RESOLVE_DEPENDS" ]];then
                if [[ -z "${BEGINNING_NO_REVERSE_DEPENDS}" ]];then
                    depends=$(reverse $(${daemon}_depends))
                else
                    depends=$(${daemon}_depends)
                fi
                type -t ${daemon}_depends >/dev/null 2>&1 && beginning_daemon_stop "${depends}"
            fi
            if type -t ${daemon}_stop >/dev/null 2>&1;then
                printf "Stopping \`%s\`..." "${daemon}" | tabprefix
                ${daemon}_start
                if [[ $? -eq 0 ]];then
                    rm -f /run/beginning/{failed,started}.${daemon}
                    printf " done.\n"
                else
                    rm -f /run/beginning/started.${daemon}
                    date +%s > /run/beginning/failed.${daemon}
                    printf " failed.\n"
                fi
            fi
        fi
    done
}

# check if $1 is a pid which is exists
# if we are root, we use the bash builtin kill, and if not we use ps
# since kill will return 'operation not permitted' with a 1 errcode, which
# would be interpreted as the pid not existing
pidexists() {
    if [[ "${1:0:1}" == [0-9] && ! -r "${1}" ]];then
        local pid=${1}
    elif [[ -r "${1}" ]];then
        local pid=$(<"${1}")
    elif [[ "${1:0:1}" != [0-9] && ! -r "${1}" ]];then
        return 1
    fi
    if [[ $UID -eq 0 ]];then
        kill -0 "$pid" >/dev/null 2>&1; return $?
    else
        ps "$pid" >/dev/null 2>&1; return $?
    fi
}

killall5() {
    for pid in $(pgrep . | egrep -v "^(1|$$|$PPID)$");do
        kill "${1:--15}" "$pid" >/dev/null 2>&1
    done
}

keeprunning() {
    local err
    local daemon="$1"
    shift
    while [[ "${err:-1}" -ne 0 ]];do
        local i=$(( ${i:-1} + 1 ))
        "$@"; local err=$?
        sleep 1
        if [[ "$i" -eq 10 ]];then
            break
        fi
    done
}

