#!/bin/bash
#
# Beginning - an init system that isn't smarter than you
#
# Copyright (c) 2015 Kylie McClain <somasis@exherbo.org>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

# prevent any funny business
BEGINNING_RUNNER=

umask 022

export PATH="/bin:/sbin"

BEGINNING_PLATFORM=$(uname -s)

LIBDIR="${LIBDIR:-/lib}"
SYSCONFDIR="${SYSCONFDIR:-/etc}"

BEGINNING_LIB="${LIBDIR}"/beginning
BEGINNING_RC="${BEGINNING_LIB}"/rc.d
USER_RC="${SYSCONFDIR}"/rc.d

# os-release contains things such as distro name, distro's 'color'...
[[ -r "${LIBDIR}"/os-release ]]     && . "${LIBDIR}"/os-release
[[ -r "${BEGINNING_LIB}"/rc.conf ]] && . "${BEGINNING_LIB}"/rc.conf
[[ -r "${SYSCONFDIR}"/os-release ]] && . "${SYSCONFDIR}"/os-release
[[ -r "${SYSCONFDIR}"/rc.conf ]]    && . "${SYSCONFDIR}"/rc.conf

if [[ ! -r "${BEGINNING_LIB}"/rc.conf && ! -f "${SYSCONFDIR}"/rc.conf ]];then
    printf 'Could not read/find %s/rc.conf or %s/rc.conf, going into emergency shell...\n' "${BEGINNING_LIB}" "${SYSCONFDIR}"
    emergency_shell
fi

# If os-release gives us a color, use it; if not, use the reset color code
ANSI_COLOR="\e[${ANSI_COLOR:-0}m"
[[ -z "$PRETTY_NAME" ]] && PRETTY_NAME="${NAME:-$BEGINNING_PLATFORM}"


status() {
    local stat="${1^^}";shift
    case "${stat}" in
        STARTED)    printf "\r\e[1;42m[ ${stat} ]\e[0m %s\n" "$@"   ;; # green bg   [white]
        FAILURE)    printf "\r\e[1;41m[ ${stat} ]\e[0m %s\n" "$@"   ;; # red bg     [white]
        STOPPED)    printf "\r\e[1;41m[ ${stat} ]\e[0m %s\n" "$@"   ;; # red bg     [white]
        UNKNOWN)    printf "\r\e[1;40m[ ${stat} ]\e[0m %s\n" "$@"   ;; # black bg   [white]
        NOTHING)    printf "\r\e[1;40m[         ]\e[0m %s\n" "$@"   ;; # black bg   [white]
        CUSTOM)     printf "\r\e[1;40m[         ]\e[0m %s"   "$@"   ;; # black bg   [white]
    esac
}

emergency_shell() {
    while true;do
        sulogin && exec "$@"
    done
}

reverse() {
    if [[ $# -ne 0 ]];then
        local rev="$1"
        shift
        reverse "$@"
        printf '%s\n' "$rev"
    fi
}

func_exists() {
    local func err
    for func in $@;do
        type -t "${func}" >/dev/null 2>&1
        err=$?
        [[ "${err}" -eq 0 ]] || break
    done
    [[ "${err}" -eq 0 ]] || return $?
}

prog_exists() {
    local prog err
    for prog in $@;do
        type -fPt "${prog}" >/dev/null 2>&1
        err=$?
        [[ "${err}" -eq 0 ]] || break
    done
    [[ "${err}" -eq 0 ]] || return $?
}

beginning_daemon_file() {
    local daemon
    for daemon in $@;do
        if [[ -f "${USER_RC}/${daemon}" ]];then
            echo "${USER_RC}/${daemon}"
        elif [[ -f "${BEGINNING_RC}/${daemon}" ]];then
            echo "${BEGINNING_RC}/${daemon}"
        else
            return 1
        fi
    done
}

beginning_daemon_list() {
    local daemon daes=()
    if [[ "$#" -gt 1 ]];then
        daes=( "$@" )
    else
        daes=( ${BEGINNING_RC}/* ${USER_RC}/* )
    fi
    for daemon in "${daes[@]}";do
        daemon=${daemon##*/}
        daemon_file=$(beginning_daemon_file "${daemon}")
        if [[ "${daemon_file}" ]];then
            . "${daemon_file}" || printf "%s: invalid script, possible syntax errors.\n" "${daemon}" >&2
            case "${1^^}" in
                STARTED)
                    if func_exists ${daemon}_status && ${daemon}_exists && ${daemon}_status;then
                        echo "${daemon}"
                    fi
                ;;
                STOPPED)
                    if func_exists ${daemon}_status && ${daemon}_exists && ! ${daemon}_status;then
                        echo ${daemon}
                    fi
                ;;
                EXISTS)
                    if func_exists ${daemon}_exists && ${daemon}_exists;then
                        echo ${daemon}
                    fi
                ;;
                ALL)
                    echo ${daemon}
                ;;
            esac
        fi
    done
}

beginning_daemon_provider() {
    local action="${1}"
    local daemon="${2}"

    d_list=
    d_list=(
        $(for d in $(echo ${BEGINNING_RC}/* ${USER_RC}/*);do
            if [[ -r "${USER_RC}/${d##*/}" ]];then
                d="${USER_RC}/${d##*/}"
            elif [[ -r "${BEGINNING_RC}/${d##*/}" ]];then
                d="${BEGINNING_RC}/${d##*/}"
            fi
            . "$d"
            if func_exists ${d##*/}_exists && ${d##*/}_exists;then
                if [[ " $(func_exists ${d##*/}_provides && ${d##*/}_provides) " == *" ${daemon} "* ]];then
                    echo "${d##*/}"
                fi
            fi
        done 2>/dev/null)
    )
    local provider=
    local provider=${daemon^^}_PROVIDER
    local provider=${!provider}
    if [[ -n "${provider}" && " ${d_list[@]} " == *" ${provider} "* ]];then
        d_list=( "${provider}" )
    elif [[ -n "${provider}" && " ${d_list[@]} " != *" ${provider} "* ]];then
        status FAILURE "${daemon}: invalid provider. Possible providers: ${d_list[*]}"
        return 1
    elif [[ -z "${provider}" && -n "${d_list[@]}" ]];then
        status FAILURE "${daemon}: provider is not set. Possible providers: ${d_list[*]}"
        return 2
    fi
    if [[ -n "${d_list}" ]];then
        beginning_daemon_${action} "${d_list}"; return $?
    else
        status FAILURE "${daemon}: has no providers. You need to install one."
        return 3
    fi
}

beginning_daemon_start() {
    export BEGINNING_PHASE=start
    local daemon
    for daemon in ${@};do
        daemon_file=$(beginning_daemon_file "${daemon}") || continue
        if [[ "${daemon_file}" ]];then
            . "${daemon_file}" || status FAILURE "%s: invalid script, possible syntax errors.\n" "${daemon}" >&2
            if func_exists ${daemon}_virtual && ${daemon}_virtual;then
                beginning_daemon_provider start "${daemon}"; continue
            fi
            if func_exists ${daemon}_exists && ${daemon}_exists;then
                true
            else
                continue
            fi
            if func_exists ${daemon}_status;then
                if ! ${daemon}_status;then
                    if [[ -z "$BEGINNING_NO_RESOLVE_DEPENDS" ]];then
                        BEGINNING_RESOLVING_DEPS=true
                        func_exists ${daemon}_depends && beginning_daemon_start $(${daemon}_depends)
                        BEGINNING_RESOLVING_DEPS=
                    fi
                    if func_exists ${daemon}_wants;then
                        beginning_daemon_start $(${daemon}_wants) || true
                    fi
                    if func_exists ${daemon}_start;then
                        status CUSTOM "${daemon}"
                        ${daemon}_start
                        if [[ $? -eq 0 ]];then
                            status STARTED "${daemon}"
                        else
                            status FAILURE "${daemon}"
                        fi
                    fi
                else
                    [[ -z "${BEGINNING_RESOLVING_DEPS}" ]] && [[ "${BEGINNING_RUNNER}" != init ]] && status STARTED "${daemon}: already started"
                fi
            fi
        fi
    done
}

beginning_daemon_stop() {
    export BEGINNING_PHASE=stop
    local daemon
    for daemon in ${@};do
        if [[ " ${BEGINNING_SKIP_DEPS} " == *" ${daemon} "* ]];then
            continue
        fi
        daemon_file=$(beginning_daemon_file "${daemon}")
        if [[ "${daemon_file}" ]];then
            . "${daemon_file}" || printf "%s: invalid script, possible syntax errors.\n" "${daemon}" >&2
            if func_exists ${daemon}_virtual && ${daemon}_virtual;then
                beginning_daemon_provider stop "${daemon}"; continue
            fi
            if func_exists ${daemon}_exists && ${daemon}_exists;then
                true
            else
                continue
            fi
            BEGINNING_RESOLVING_DEPS=true
            d_list=(
                $(for d in ${BEGINNING_RC}/* ${USER_RC}/*;do
                    if [[ -r "${USER_RC}/${d##*/}" ]];then
                        d="${USER_RC}/${d##*/}"
                    elif [[ -r "${BEGINNING_RC}/${d##*/}" ]];then
                        d="${BEGINNING_RC}/${d##*/}"
                    fi
                    . "$d" && {
                        func_exists ${d##*/}_depends && ${d##*/}_depends
                    } |
                    while read line;do
                        [[ " $line " == *" ${daemon} "* ]] && echo "${d##*/}"
                    done
                done 2>/dev/null)
            )
            depends=( )
            for dep in ${d_list[@]};do
                dname=${dep/:*}
                [[ " ${BEGINNING_SKIP_DEPS} " == *" ${dname} "* ]] && continue
                depends+=( "${dname}" )
            done
            if [[ " ${depends[@]} " != *" ${daemon} "* ]];then
                BEGINNING_SKIP_DEPS="${BEGINNING_SKIP_DEPS} ${daemon} " beginning_daemon_stop ${depends[@]}
            fi
            if func_exists ${daemon}_status;then
                if ${daemon}_status;then
                    if func_exists ${daemon}_stop;then
                        status CUSTOM "${daemon}"
                        ${daemon}_stop
                        if [[ $? -eq 0 ]];then
                            status STOPPED "${daemon}"
                        else
                            status FAILURE "${daemon}"
                        fi
                    fi
                else
                    [[ -z "${BEGINNING_SKIP_DEPS}" ]] && status FAILURE "${daemon}: already stopped"
                fi
            fi
        fi
    done
}

# check if $1's contents is a pid which is exists
# if we are root, we use the bash builtin kill, and if not we use ps
# since kill will return 'operation not permitted' with a 1 errcode, which
# would be interpreted as the pid not existing
pidfileexists() {
    if [[ -r "${1}" ]];then
        local pid=$(<"${1}")
    else
        return 1
    fi
    if [[ $UID -eq 0 ]];then
        kill -0 "$pid" >/dev/null 2>&1; return $?
    else
        ps "$pid" >/dev/null 2>&1; return $?
    fi
}

pidfilekill() {
    [[ $# -gt 1 ]] && local sig="${1}" && shift
    if [[ -r "${@}" ]];then
        local pid=$(<"${1}")
    else
        return 1
    fi
    kill ${sig} "$pid" >/dev/null 2>&1
    return $?
}

killall5() {
    for pid in $(pgrep . | egrep -v "^(1|$$|$PPID)$");do
        kill "${1:--15}" "$pid" >/dev/null 2>&1
    done
}

keeprunning() {
    local err
    local daemon="$1"
    shift
    while [[ "${err:-1}" -ne 0 ]];do
        local i=$(( ${i:-1} + 1 ))
        "$@"; local err=$?
        sleep 1
        if [[ "$i" -eq 10 ]];then
            break
        fi
    done
}

tab() {
    if [[ "$@" ]];then
        if [[ "${TABS}" ]];then
            printf '\t%s' "${@}"
        else
            printf '%s' "${@}"
        fi
    else
        if [[ "${TABS}" ]];then
            while read line;do
                printf "\t%s\n" "${line}"
            done
        else
            while read line;do
                printf "%s\n" "${line}"
            done
        fi
    fi
}

rchook() {
    if func_exists "$@";then
        status NOTHING "rchook: ${@}"
        if "$@";then
            status STARTED "rchook: ${@}"
        else
            status FAILURE "rchook: ${@}"
        fi
    fi
}
