#!/bin/bash
#
# Beginning - an rc program that doesn't try to be too clever
#
# Copyright (c) 2015 Kylie McClain <somasis@exherbo.org>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

umask 022

export PATH="/bin:/sbin"

# os-release contains things such as distro name, distro's 'color'...
[[ -r ${LIBDIR:-/lib}/os-release ]] && . ${LIBDIR:-/lib}/os-release
[[ -r ${BEGINNING_LIB:-/lib/beginning}/rc.conf ]] && . ${BEGINNING_LIB:-/lib/beginning}/rc.conf
[[ -r ${SYSCONFDIR:-/etc}/os-release ]] && . ${SYSCONFDIR:-/etc}/os-release
[[ -r ${SYSCONFDIR:-/etc}/rc.conf ]] && . ${SYSCONFDIR:-/etc}/rc.conf

if [[ ! -r ${BEGINNING_LIB:-/lib/beginning}/rc.conf && ! -f ${SYSCONFDIR:-/etc}/rc.conf ]];then
    printf 'Could not read/find %s/rc.conf or %s/rc.conf, going into emergency shell...\n' "${BEGINNING_LIB:-/lib/beginning}" "${SYSCONFDIR:-/etc}"
    emergency_shell
fi

# If os-release gives us a color, use it; if not, use the reset color code
ANSI_COLOR="\e[${ANSI_COLOR:-0}m"
[[ -z "$PRETTY_NAME" ]] && PRETTY_NAME=${NAME:-Linux}


status() {
    local stat="${1^^}";shift
    case "${stat}" in
        STARTED)    printf "\r\e[1;42m[x]\e[0m %s\n" "$@"   ;; # green bg   [x]
        FAILED)     printf "\r\e[1;41m[x]\e[0m %s\n" "$@"   ;; # red bg     [x]
        STOPPED)    printf "\r\e[1;41m[ ]\e[0m %s\n" "$@"   ;; # red bg     [ ]
        NOTHING)    printf "\r\e[1;40m[ ]\e[0m %s\n" "$@"   ;; # black bg   [ ]
        UNKNOWN|*)  printf "\r\e[1;40m[?]\e[0m %s\n" "$@"   ;; # black bg   [?]
    esac
}

emergency_shell() {
    while true;do
        sulogin && exec "$@"
    done
}

reverse() {
    if [[ $# -ne 0 ]];then
        local rev="$1"
        shift
        reverse "$@"
        printf '%s\n' "$rev"
    fi
}

unset_phases() {
    for func in ${daemon:-$1}_{start,reload,restart,stop,depends,exists,status};do
        type -t "${func}" >/dev/null 2>&1 && unset -f "${func}"
    done
}

beginning_daemon_provider() {
    local action="${1}"
    local daemon="${2}"

    d_list=
    d_list=(
        $(for d in $(echo ${BEGINNING_LIB}/rc.d/* ${USER_RC}/*);do
            if [[ -r "${USER_RC}/${d##*/}" ]];then
                d="${USER_RC}/${d##*/}"
            elif [[ -r "${BEGINNING_LIB}/rc.d/${d##*/}" ]];then
                d="${BEGINNING_LIB}/rc.d/${d##*/}"
            fi
            . "$d"
            if [[ " $(type -t ${d##*/}_provides >/dev/null 2>&1 && ${d##*/}_provides) " == *" ${daemon} "* ]];then
                echo "${d##*/}"
            fi
        done 2>/dev/null)
    )
    local provider=
    local provider=${daemon^^}_PROVIDER
    local provider=${!provider}
    if [[ -n "${provider}" && " ${d_list[@]} " == *" ${provider} "* ]];then
        d_list=( "${provider}" )
    elif [[ -n "${provider}" && " ${d_list[@]} " != *" ${provider} "* ]];then
        d_list=( "${d_list[1]}" )
        [[ "${action}" == start ]] && status UNKNOWN "${daemon}: provider is not valid. Starting first possible provider: ${d_list[1]}"
        [[ "${action}" == stop ]] && status UNKNOWN "${daemon}: provider is not valid. Stopping first possible provider: ${d_list[1]}"
    elif [[ -z "${provider}" && -n "${d_list[@]}" ]];then
        status FAILED "${daemon}: provider is not set. Possible providers: ${d_list[*]}"
        return 2
    fi
    if [[ -n "${d_list}" ]];then
        beginning_daemon_${action} "${d_list}"; return $?
    else
        status FAILED "${daemon}: has no providers. You need to set one."
        return 3
    fi
}
beginning_daemon_start() {
    export BEGINNING_PHASE=start
    local daemon
    for daemon in ${@};do
        if [[ -f "${USER_RC}/${daemon}" ]];then
            daemon_file="${USER_RC}/${daemon}"
        elif [[ -f "${BEGINNING_LIB}/rc.d/${daemon}" ]];then
            daemon_file="${BEGINNING_LIB}/rc.d/${daemon}"
        else
            continue
        fi
        if [[ "${daemon_file}" ]];then
            . "${daemon_file}" || printf "%s: invalid script, possible syntax errors.\n" "${daemon}" >&2
            if type -t ${daemon}_virtual >/dev/null 2>&1 && ${daemon}_virtual;then
                beginning_daemon_provider start "${daemon}"; return $?
            fi
            if type -t ${daemon}_exists >/dev/null 2>&1 && ${daemon}_exists >/dev/null 2>&1;then
                true
            else
                continue
            fi
            if type -t ${daemon}_status >/dev/null 2>&1;then
                if ! ${daemon}_status;then
                    if [[ -z "$BEGINNING_NO_RESOLVE_DEPENDS" ]];then
                        type -t ${daemon}_depends >/dev/null 2>&1 && beginning_daemon_start $(${daemon}_depends)
                    fi
                    if type -t ${daemon}_start >/dev/null 2>&1;then
                        printf "[ ] %s" "${daemon}"
                        ${daemon}_start
                        if [[ $? -eq 0 ]];then
                            status STARTED
                        else
                            status FAILED
                        fi
                    fi
                else
                    status FAILED "${daemon}: already started"
                fi
            fi
        fi
    done
}

beginning_daemon_stop() {
    export BEGINNING_PHASE=stop
    local daemon
    for daemon in ${@};do
        if [[ " ${BEGINNING_SKIP_DEPS} " == *" ${daemon} "* ]];then
            continue
        fi
        if [[ -f "${USER_RC}/${daemon}" ]];then
            daemon_file="${USER_RC}/${daemon}"
        elif [[ -f "${BEGINNING_LIB}/rc.d/${daemon}" ]];then
            daemon_file="${BEGINNING_LIB}/rc.d/${daemon}"
        else
            printf "Cannot find rc.d script for %s. Skipping.\n" "${daemon}" >&2
        fi
        if [[ "${daemon_file}" ]];then
            . "${daemon_file}" || printf "%s: invalid script, possible syntax errors.\n" "${daemon}" >&2
            if type -t ${daemon}_virtual >/dev/null 2>&1 && ${daemon}_virtual;then
                beginning_daemon_provider stop "${daemon}"; return $?
            fi
            if type -t ${daemon}_exists >/dev/null 2>&1 && ${daemon}_exists >/dev/null 2>&1;then
                true
            else
                continue
            fi
                d_list=(
                    $(for d in $(echo ${BEGINNING_LIB}/rc.d/* ${USER_RC}/*);do
                        if [[ -r "${USER_RC}/${d##*/}" ]];then
                            d="${USER_RC}/${d##*/}"
                        elif [[ -r "${BEGINNING_LIB}/rc.d/${d##*/}" ]];then
                            d="${BEGINNING_LIB}/rc.d/${d##*/}"
                        fi
                        . "$d" && type -t ${d##*/}_depends >/dev/null 2>&1 && ${d##*/}_depends | \
                        while read line;do
                            [[ " $line " == *" ${daemon} "* ]] && echo "${d##*/}"
                        done
                    done 2>/dev/null)
                )
                depends=( )
                for dep in ${d_list[@]};do
                    dname=${dep/:*}
                    [[ " ${BEGINNING_SKIP_DEPS} " == *" ${dname} "* ]] && continue
                    depends+=( "${dname}" )
                done
                if [[ " ${depends[@]} " != *" ${daemon} "* ]];then
                    BEGINNING_SKIP_DEPS="${BEGINNING_SKIP_DEPS} ${daemon} " beginning_daemon_stop ${depends[@]}
                fi
                if type -t ${daemon}_status >/dev/null 2>&1;then
                    if ${daemon}_status;then
                        printf "[ ] %s" "${daemon}"
                        if type -t ${daemon}_stop >/dev/null 2>&1;then
                            ${daemon}_stop
                            if [[ $? -eq 0 ]];then
                                status STOPPED
                            else
                                status FAILED
                            fi
                        fi
                    else
                        status FAILED "${daemon}: already stopped"
                    fi
                fi
        fi
    done
}

# check if $1's contents is a pid which is exists
# if we are root, we use the bash builtin kill, and if not we use ps
# since kill will return 'operation not permitted' with a 1 errcode, which
# would be interpreted as the pid not existing
pidfileexists() {
    if [[ -r "${1}" ]];then
        local pid=$(<"${1}")
    else
        return 1
    fi
    if [[ $UID -eq 0 ]];then
        kill -0 "$pid" >/dev/null 2>&1; return $?
    else
        ps "$pid" >/dev/null 2>&1; return $?
    fi
}

killall5() {
    for pid in $(pgrep . | egrep -v "^(1|$$|$PPID)$");do
        kill "${1:--15}" "$pid" >/dev/null 2>&1
    done
}

keeprunning() {
    local err
    local daemon="$1"
    shift
    while [[ "${err:-1}" -ne 0 ]];do
        local i=$(( ${i:-1} + 1 ))
        "$@"; local err=$?
        sleep 1
        if [[ "$i" -eq 10 ]];then
            break
        fi
    done
}

tab() {
    if [[ "$@" ]];then
        if [[ "${TABS}" ]];then
            printf '\t%s' "${@}"
        else
            printf '%s' "${@}"
        fi
    else
        if [[ "${TABS}" ]];then
            while read line;do
                printf "\t%s\n" "${line}"
            done
        else
            while read line;do
                printf "%s\n" "${line}"
            done
        fi
    fi
}

rchook() {
    if type -t "$@" >/dev/null 2>&1;then
        status NOTHING "rchook: ${@}"
        if "$@";then
            status STARTED "rchook: ${@}"
        else
            status FAILED "rchook: ${@}"
        fi
    fi
}

