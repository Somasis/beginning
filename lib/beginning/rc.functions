#!/bin/bash
#
# Beginning - an rc program that doesn't try to be too clever
#
# Copyright (c) 2015 Kylie McClain <somasis@exherbo.org>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

umask 022

export PATH="/bin:/sbin"

# os-release contains things such as distro name, distro's 'color'...
[[ -r /lib/os-release ]] && . /lib/os-release
[[ -r /lib/beginning/rc.conf ]] && . /lib/beginning/rc.conf
[[ -r /etc/os-release ]] && . /etc/os-release
[[ -r /etc/rc.conf ]] && . /etc/rc.conf

if [[ ! -r /lib/beginning/rc.conf && ! -f /etc/rc.conf ]];then
    printf 'Could not read/find %s/rc.conf or %s/rc.conf, going into emergency shell...\n' /lib/beginning /etc
    emergency_shell
fi

# If os-release gives us a color, use it; if not, use the reset color code
ANSI_COLOR="\e[${ANSI_COLOR:-0}m"
[[ -z "$PRETTY_NAME" ]] && PRETTY_NAME=${NAME:-Linux}


emergency_shell() {
    while true;do
        sulogin && exec "$@"
    done
}

reverse() {
    if [[ $# -ne 0 ]];then
        local rev="$1"
        shift
        reverse "$@"
        printf '%s\n' "$rev"
    fi
}

unset_phases() {
    for func in ${daemon:-$1}_{start,reload,restart,stop,depends,exists,status};do
        type -t "${func}" >/dev/null 2>&1 && unset -f "${func}"
    done
}

beginning_daemon_start() {
    export BEGINNING_PHASE=start
    local daemon
    for daemon in ${@};do
        if [[ -f "/etc/rc.d/${daemon}" ]];then
            daemon_file="/etc/rc.d/${daemon}"
        elif [[ -f "/lib/beginning/rc.d/${daemon}" ]];then
            daemon_file="/lib/beginning/rc.d/${daemon}"
        else
            continue
        fi
        if [[ "${daemon_file}" ]];then
            . "${daemon_file}" || printf "Starting \`%s\`.. invalid script, possible syntax errors.\n" "${daemon}" >&2
            if type -t ${daemon}_virtual >/dev/null 2>&1 && ${daemon}_virtual;then
                d_list=(
                    $(for d in $(echo /lib/beginning/rc.d/* /etc/rc.d/*);do
                        if [[ -r "/etc/rc.d/${d##*/}" ]];then
                            d="/etc/rc.d/${d##*/}"
                        elif [[ -r "/lib/beginning/rc.d/${d##*/}" ]];then
                            d="/lib/beginning/rc.d/${d##*/}"
                        fi
                        . "$d"
                        if [[ " $(type -t ${d##*/}_provides >/dev/null 2>&1 && ${d##*/}_provides) " == *" ${daemon} "* ]];then
                            echo "${d##*/}"
                        fi
                    done 2>/dev/null)
                )
                provider=
                provider=${daemon^^}_PROVIDER
                provider=${!provider}
                if [[ -n "${provider}" && " ${d_list[@]} " == *" ${provider} "* ]];then
                    d_list=( "${provider}" )
                elif [[ -n "${provider}" && " ${d_list[@]} " != *" ${provider} "* ]];then
                    printf "\`%s\` provider is not valid. Starting all possible providers.\n" "${daemon}" >&2
                fi
                if [[ -n "${d_list}" ]];then
                    beginning_daemon_start "${d_list}"; return $?
                else
                    printf "Starting \`%s\`... \`%s\` has no providers. Failed.\n" "${daemon}" "${daemon}" >&2
                    return 1
                fi

            fi
            if type -t ${daemon}_exists >/dev/null 2>&1 && ${daemon}_exists >/dev/null 2>&1;then
                true
            else
                continue
            fi
            if type -t ${daemon}_status >/dev/null 2>&1;then
                if ! ${daemon}_status;then
                    if [[ -z "$BEGINNING_NO_RESOLVE_DEPENDS" ]];then
                        type -t ${daemon}_depends >/dev/null 2>&1 && beginning_daemon_start $(${daemon}_depends)
                    fi
                    if type -t ${daemon}_start >/dev/null 2>&1;then
                        printf "Starting \`%s\`... " "${daemon}"
                        ${daemon}_start
                        if [[ $? -eq 0 ]];then
                            printf "done.\n"
                        else
                            printf "failed.\n"
                        fi
                    fi
                fi
            fi
        fi
    done
}

beginning_daemon_stop() {
    export BEGINNING_PHASE=stop
    local daemon
    for daemon in ${@};do
        if [[ " ${BEGINNING_SKIP_DEPS} " == *" ${daemon} "* ]];then
            continue
        fi
        if [[ -f "/etc/rc.d/${daemon}" ]];then
            daemon_file="/etc/rc.d/${daemon}"
        elif [[ -f "/lib/beginning/rc.d/${daemon}" ]];then
            daemon_file="/lib/beginning/rc.d/${daemon}"
        else
            printf "Cannot find rc.d script for %s. Skipping.\n" "${daemon}" >&2
        fi
        if [[ "${daemon_file}" ]];then
            . "${daemon_file}" || printf "%s's rc.d script is invalid. Skipping.\n" "${daemon}" >&2
            if type -t ${daemon}_virtual >/dev/null 2>&1 && ${daemon}_virtual;then
                d_list=(
                    $(for d in $(echo /lib/beginning/rc.d/* /etc/rc.d/*);do
                        if [[ -r "/etc/rc.d/${d##*/}" ]];then
                            d="/etc/rc.d/${d##*/}"
                        elif [[ -r "/lib/beginning/rc.d/${d##*/}" ]];then
                            d="/lib/beginning/rc.d/${d##*/}"
                        fi
                        . "$d"
                        if [[ " $(type -t ${d##*/}_provides >/dev/null 2>&1 && ${d##*/}_provides) " == *" ${daemon} "* ]];then
                            echo "${d##*/}"
                        fi
                    done 2>/dev/null)
                )
                provider=
                provider=${daemon^^}_PROVIDER
                provider=${!provider}
                if [[ -n "${provider}" && " ${d_list[@]} " == *" ${provider} "* ]];then
                    d_list=( "${provider}" )
                elif [[ -n "${provider}" && " ${d_list[@]} " != *" ${provider} "* ]];then
                    printf "\`%s\` provider is not valid. Stopping all possible providers.\n" "${daemon}" >&2
                fi
                if [[ -n "${d_list}" ]];then
                    beginning_daemon_stop "${d_list}"; return $?
                else
                    printf "Stopping \`%s\`... \`%s\` has no providers. Failed.\n" "${daemon}" "${daemon}" >&2
                    return 1
                fi
            fi
            if type -t ${daemon}_exists >/dev/null 2>&1 && ${daemon}_exists >/dev/null 2>&1;then
                true
            else
                continue
            fi
                d_list=(
                    $(for d in $(echo /lib/beginning/rc.d/* /etc/rc.d/*);do
                        if [[ -r "/etc/rc.d/${d##*/}" ]];then
                            d="/etc/rc.d/${d##*/}"
                        elif [[ -r "/lib/beginning/rc.d/${d##*/}" ]];then
                            d="/lib/beginning/rc.d/${d##*/}"
                        fi
                        . "$d" && type -t ${d##*/}_depends >/dev/null 2>&1 && ${d##*/}_depends | \
                        while read line;do
                            [[ " $line " == *" ${daemon} "* ]] && echo "${d##*/}"
                        done
                    done 2>/dev/null)
                )
                depends=( )
                for dep in ${d_list[@]};do
                    dname=${dep/:*}
                    [[ " ${BEGINNING_SKIP_DEPS} " == *" ${dname} "* ]] && continue
                    depends+=( "${dname}" )
                done
                if [[ " ${depends[@]} " != *" ${daemon} "* ]];then
                    BEGINNING_SKIP_DEPS="${BEGINNING_SKIP_DEPS} ${daemon} " beginning_daemon_stop ${depends[@]}
                fi
                if type -t ${daemon}_status >/dev/null 2>&1;then
                    if ${daemon}_status;then
                        if type -t ${daemon}_stop >/dev/null 2>&1;then
                            printf "Stopping \`%s\`..." "${daemon}"
                            ${daemon}_stop
                            if [[ $? -eq 0 ]];then
                                printf " done."
                            else
                                printf " failed."
                            fi
                            printf '\n'
                        fi
                    fi
                fi
        fi
    done
}

# check if $1 is a pid which is exists
# if we are root, we use the bash builtin kill, and if not we use ps
# since kill will return 'operation not permitted' with a 1 errcode, which
# would be interpreted as the pid not existing
pidexists() {
    if [[ "${1:0:1}" == [0-9] && ! -r "${1}" ]];then
        local pid=${1}
    elif [[ -r "${1}" ]];then
        local pid=$(<"${1}")
    elif [[ "${1:0:1}" != [0-9] && ! -r "${1}" ]];then
        return 1
    fi
    if [[ $UID -eq 0 ]];then
        kill -0 "$pid" >/dev/null 2>&1; return $?
    else
        ps "$pid" >/dev/null 2>&1; return $?
    fi
}

killall5() {
    for pid in $(pgrep . | egrep -v "^(1|$$|$PPID)$");do
        kill "${1:--15}" "$pid" >/dev/null 2>&1
    done
}

keeprunning() {
    local err
    local daemon="$1"
    shift
    while [[ "${err:-1}" -ne 0 ]];do
        local i=$(( ${i:-1} + 1 ))
        "$@"; local err=$?
        sleep 1
        if [[ "$i" -eq 10 ]];then
            break
        fi
    done
}

tab() {
    if [[ "$@" ]];then
        if [[ "${TABS}" ]];then
            printf '\t%s' "${@}"
        else
            printf '%s' "${@}"
        fi
    else
        if [[ "${TABS}" ]];then
            while read line;do
                printf "\t%s\n" "${line}"
            done
        else
            while read line;do
                printf "%s\n" "${line}"
            done
        fi
    fi
}

rchook() {
    type -t "$1" >/dev/null 2>&1 && printf 'Running %s...\n' "$1" && "$1"
}

