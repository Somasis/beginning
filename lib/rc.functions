#!/bin/bash
#
# Beginning - an init system that isn't smarter than you
#
# Copyright (c) 2015-2016 Kylie McClain <somasis@exherbo.org>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

# Set up environment, make sure it's not liable to change based on parent
umask 0022
export PATH="@@sbindir@@:@@bindir@@:/bin:/sbin"

# Variables which should always be set
BEGINNING_VERSION="@@VERSION@@"
BEGINNING_PLATFORM=$(uname -s)

BEGINNING_RUNDIR="@@runstatedir@@"/beginning
BEGINNING_STATEDIR="${BEGINNING_RUNDIR}"/state

# Read /lib/beginning/rc.conf, /etc/rc.conf, /lib/os-release, /etc/os-release
for file in {"@@libdir@@"/beginning,"@@sysconfdir@@"}/beginning.conf {"@@libdir@@","@@sysconfdir@@"}/os-release;do
    [[ -r "${file}" ]] && . "${file}"
done

# Read all executable files within /lib/beginning/rc.conf.d and /etc/rc.conf.d
for dir in {"@@libdir@@"/beginning,"@@sysconfdir@@"}/rc.conf.d;do
    if [[ -d "${dir}" ]];then
        for file in "${dir}"/*;do
            [[ -x "${file}" ]] && . "${file}"
        done
    fi
done

unset file dir

# reverse <words>
reverse() {
    local words word
    words=( "${@}" )
    # I loathe this style
    for (( word = ${#words[@]} - 1; word >= 0; word-- ));do
        echo "${words[${word}]}"
    done
}

func_exists() {
    local func err
    for func in ${@};do
        type -t "${func}" >/dev/null 2>&1
        err=$?
        [[ "${err}" -eq 0 ]] || break
    done
    [[ "${err}" -eq 0 ]] || return $?
}

prog_exists() {
    local prog err
    for prog in $@;do
        type -fPt "${prog}" >/dev/null 2>&1
        err=$?
        [[ "${err}" -eq 0 ]] || break
    done
    [[ "${err}" -eq 0 ]] || return $?
}

beginning_daemon_load() {
    local daemon file
    for daemon in $@;do
        file=$(beginning_daemon_file "${daemon}" 2>/dev/null)
        if [[ "${file}" ]];then
            . "${file}" >/dev/null 2>&1 || printf "%s: invalid script. possible syntax errors?\n" "${daemon}" >&2 && return 4
        else
            printf "%s: script not found.\n" "${daemon}" >&2
            return 3
        fi
    done
}

beginning_daemon_file() {
    local daemon
    for daemon in $@;do
        if [[ -f "${USER_RC}/${daemon}" ]];then
            echo "${USER_RC}/${daemon}"
        elif [[ -f "${BEGINNING_RC}/${daemon}" ]];then
            echo "${BEGINNING_RC}/${daemon}"
        else
            return 1
        fi
    done
}

beginning_daemon_list() {
    local daemon daes=() list="${1}"
    if [[ "$#" -gt 1 ]];then
        shift
        daes=( "$@" )
    else
        daes=( ${BEGINNING_RC}/* ${USER_RC}/* )
    fi
    for daemon in "${daes[@]}";do
        daemon=${daemon##*/}
        [[ "${daemon}" == '*' ]] && continue
        beginning_daemon_load "${daemon}" 2>/dev/null
        case "${list^^}" in
            STARTED)
                if func_exists ${daemon}_status && ${daemon}_exists && ${daemon}_status;then
                    echo "${daemon}"
                fi
            ;;
            STOPPED)
                if func_exists ${daemon}_status && ${daemon}_exists && ! ${daemon}_status;then
                    echo ${daemon}
                fi
            ;;
            NONEXISTENT)
                if func_exists ${daemon}_exists && ! ${daemon}_exists;then
                    echo ${daemon}
                fi
            ;;
            EXISTENT)
                if func_exists ${daemon}_exists && ${daemon}_exists;then
                    echo ${daemon}
                fi
            ;;
            DAEMONS)
                if ! func_exists ${daemon}_virtual;then
                    echo ${daemon}
                fi
            ;;
            VIRTUALS)
                if func_exists ${daemon}_virtual;then
                    echo ${daemon}
                fi
            ;;
            ALL)
                echo ${daemon}
            ;;
        esac
    done
}

beginning_daemon_provider() {
    local action="${1}"
    local daemon="${2}"
    local type="${3:-installed}"

    d_list=
    d_list=(
        $(for d in $(beginning_daemon_list all);do
            beginning_daemon_load "$d"
            if func_exists ${d##*/}_exists && ! ${d##*/}_exists;then
                [[ "${type}" == "installed" ]] && continue
                if [[ " $(func_exists ${d##*/}_provides && ${d##*/}_provides) " == *" ${daemon} "* ]];then
                    echo "${d##*/}"
                fi
            elif func_exists ${d##*/}_exists && ${d##*/}_exists;then
                if [[ " $(func_exists ${d##*/}_provides && ${d##*/}_provides) " == *" ${daemon} "* ]];then
                    echo "${d##*/}"
                fi
            fi
        done 2>/dev/null)
    )
    [[ "${BEGINNING_PROVIDER_LIST_ONLY}" ]] && echo "${d_list[*]}" && return 0
    local provider=
    local provider=${daemon^^}_PROVIDER
    local provider=${!provider}
    if [[ -z ${d_list[*]} ]];then
        status FAILURE "${daemon}: has no providers. You need to install one."
        return 3
    fi

    if [[ -n "${provider}" && " ${d_list[@]} " == *" ${provider} "* ]];then
        d_list=( "${provider}" )
    elif [[ -n "${provider}" && " ${d_list[@]} " != *" ${provider} "* ]];then
        status FAILURE "${daemon}: invalid provider. Possible providers: ${d_list[*]}"
        return 1
    elif [[ -z "${provider}" && -n "${d_list[@]}" ]];then
        status FAILURE "${daemon}: provider is not set. Possible providers: ${d_list[*]}"
        return 2
    fi
    if [[ -n ${d_list} ]];then # space removal intentional
        beginning_daemon_${action} "${d_list}"; return $?
    fi
}

beginning_daemon_start() {
    export BEGINNING_PHASE=start
    local daemon
    for daemon in ${@};do
        beginning_daemon_load "${daemon}"
        if func_exists ${daemon}_virtual && ${daemon}_virtual;then
            if [[ -z "$BEGINNING_NO_RESOLVE_DEPENDS" ]];then
                BEGINNING_RESOLVING_DEPS=true
                func_exists ${daemon}_depends && beginning_daemon_start $(${daemon}_depends)
                BEGINNING_RESOLVING_DEPS=
            fi
            if func_exists ${daemon}_wants;then
                BEGINNING_RESOLVING_DEPS=true
                beginning_daemon_start $(${daemon}_wants) || true
                BEGINNING_RESOLVING_DEPS=
            fi
            beginning_daemon_provider start "${daemon}"
            continue
        fi
        if func_exists ${daemon}_exists && ${daemon}_exists;then
            true
        else
            continue
        fi
        if func_exists ${daemon}_status;then
            if ! ${daemon}_status;then
                if [[ -z "$BEGINNING_NO_RESOLVE_DEPENDS" ]];then
                    BEGINNING_RESOLVING_DEPS=true
                    func_exists ${daemon}_depends && beginning_daemon_start $(${daemon}_depends)
                    BEGINNING_RESOLVING_DEPS=
                fi
                if func_exists ${daemon}_wants;then
                    BEGINNING_RESOLVING_DEPS=true
                    beginning_daemon_start $(${daemon}_wants) || true
                    BEGINNING_RESOLVING_DEPS=
                fi
                if func_exists ${daemon}_start;then
                    status CUSTOM "${daemon}"
                    ${daemon}_start
                    if [[ $? -eq 0 ]];then
                        status STARTED "${daemon}"
                    else
                        status FAILURE "${daemon}"
                    fi
                fi
            else
                [[ -z "${BEGINNING_RESOLVING_DEPS}" ]] && [[ "${BEGINNING_RUNNER}" != rc.init ]] && status STARTED "${daemon}: already started"
            fi
        fi
    done
}

beginning_daemon_stop() {
    export BEGINNING_PHASE=stop
    local daemon
    for daemon in ${@};do
        if [[ " ${BEGINNING_SKIP_DEPS} " == *" ${daemon} "* ]];then
            continue
        fi
        beginning_daemon_load "${daemon}"
        if func_exists ${daemon}_virtual && ${daemon}_virtual;then
            beginning_daemon_provider stop ${daemon}; continue
        elif ! func_exists ${daemon}_exists || func_exists ${daemon}_exists && ! ${daemon}_exists;then
            continue
        fi
        BEGINNING_RESOLVING_DEPS=true
        d_list=(
            $(for d in $(beginning_daemon_list all);do
                beginning_daemon_load "$d" || true
                func_exists ${d}_depends && ${d}_depends |
                while read line;do
                    [[ " $line " == *" ${daemon} "* ]] && echo "${d}"
                done
            done)
        )
        depends=( )
        for dep in ${d_list[@]};do
            dname=${dep/:*}
            [[ " ${BEGINNING_SKIP_DEPS} " == *" ${dname} "* ]] && continue
            depends+=( "${dname}" )
        done
        if [[ " ${depends[@]} " != *" ${daemon} "* ]];then
            BEGINNING_SKIP_DEPS="${BEGINNING_SKIP_DEPS} ${daemon} " beginning_daemon_stop ${depends[@]}
        fi
        if func_exists ${daemon}_status;then
            if ${daemon}_status;then
                if func_exists ${daemon}_stop;then
                    status CUSTOM "${daemon}"
                    ${daemon}_stop
                    if [[ $? -eq 0 ]];then
                        status STOPPED "${daemon}"
                    else
                        status FAILURE "${daemon}"
                    fi
                fi
            else
                [[ -z "${BEGINNING_SKIP_DEPS}" ]] && status FAILURE "${daemon}: already stopped"
            fi
        fi
    done
}

beginning_daemon_do() {
    local daemon="$1" action="$2" require_started="${3:-true}"
    if func_exists ${daemon}_${action};then
        if [[ "${require_started,,}" == "true" ]];then
            if ! ${daemon}_status;then
                status FAILURE "${daemon}: must be running for \`${action}\`"
                return 1
            fi
        fi
        status CUSTOM "${daemon}${action:+: $action}"
        ${daemon}_${action}
        if [[ $? -eq 0 ]];then
            status SUCCESS "${daemon}"
        else
            status FAILURE "${daemon}"
            return 2
        fi
    fi
}

beginning_daemon_status() {
    local status="$1" d
    shift
    for d in $@;do
        if [[ -z $(beginning_daemon_list "${status}" "${d}") ]];then
            return 1
        else
            return 0
        fi
    done
}

beginning_pid_exists() {
    local pid="$1"

    case "${BEGINNING_PLATFORM}" in
        Linux)
            [[ -e /proc/${pid} ]]; return $?
        ;;
    esac

    # if we are root, we use the bash builtin kill, and if not we use ps
    # since kill will return 'operation not permitted' with a 1 errcode, which
    # would be interpreted as the pid not existing
    #if [[ "$UID" -eq 0 ]];then
    #    kill -0 "$pid" >/dev/null 2>&1; return $?
    #else
    #    ps "$pid" >/dev/null 2>&1; return $?
    #fi
}

# beginning_pidfile <daemon>
#   print the pid of a daemon
beginning_pidfile() {
    local daemon="${1}"

    if [[ -f "${pid}" ]];then
        local pid=$(<"${pid}")
    elif [[ -f "${BEGINNING_PIDDIR}"/"${pid}" ]];then
        local pid=$(<"${BEGINNING_PIDDIR}"/"${pid}")
    elif [[ -f "@@runstatedir@@"/"${pid}" ]];then
        local pid=$(<"@@runstatedir@@"/"${pid}")
    elif [[ -f "@@runstatedir@@"/"${pid}".pid ]];then
        local pid=$(<"@@runstatedir@@"/"${pid}".pid)
    else
        return 1
    fi
}

# beginning_pidfile_write <pid> <daemon>
#   write a pid to ${BEGINNING_PIDDIR}/${daemon}
beginning_pidfile_write() {
    local pid="${1}"
    local daemon="${2}"

    printf '%s' "${pid}" > "${BEGINNING_PIDDIR}"/"${daemon}"
}

# beginning_pidfile_signal <pid file> [signal]
#   without [signal], send TERM
beginning_pidfile_signal() {
    local pid="${1}"
    local signal="${2:-SIGTERM}"

    if [[ -f "${pid}" ]];then
        local pid=$(<"${pid}")
    elif [[ -f "${BEGINNING_PIDDIR}"/"${pid}" ]];then
        local pid=$(<"${BEGINNING_PIDDIR}"/"${pid}")
    elif [[ -f "@@runstatedir@@"/"${pid}" ]];then
        local pid=$(<"@@runstatedir@@"/"${pid}")
    elif [[ -f "@@runstatedir@@"/"${pid}".pid ]];then
        local pid=$(<"@@runstatedir@@"/"${pid}".pid)
    else
        return 1
    fi
    kill -"${signal}" "${pid}" >/dev/null 2>&1
    return $?
}

# beginning_signal_all [signal]
# without [signal], send TERM
beginning_signal_all() {
    local signal="${1:-SIGTERM}"

    local pid
    for pid in $(pgrep . | egrep -v "^(1|$$|${PPID})$");do
        disown "${pid}" >/dev/null 2>&1 # hide Killed message from bash
        kill -"${signal}" "${pid}" >/dev/null 2>&1
    done
}

# beginning_set_status <daemon> <status> [custom status message]
beginning_set_status() {
    local daemon="${1}"
    local status="${2,,}"
    local custom="${3:-}"

    local daemon_file="${BEGINNING_STATEDIR}"/"${daemon}"
    if [[ -n "${custom}" ]];then
        status="${status}:${custom}"
    fi

    printf '%s' "${status}" > "${daemon_file}"
}

